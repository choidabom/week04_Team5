# 2098: 외판원 순회
# 1부터 N번까지 도시, 외판원 => 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로 계획, 단 한 번 갔던 도시로는 다시 못 감
# 각 도시간 이동 비용 행렬 W[i][j] => 즉 도시 i에서 도시 j로 가기 위한 비용 
# W[i][j]와 W[j][i]는 다름, W[i][i] = 0, W[i][j]=0인 경우도 있을 수 있음
# N과 비용 행렬 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하시오. 

import sys
sys.stdin = open("2098/input.txt","r")
input = sys.stdin.readline
print = sys.stdout.write
sys.setrecursionlimit(10**8)
INF = sys.maxsize

# 자자, 도시의 갯수를 줄거야 예제는 4니깐 총 4개의 도시를 줄거고 우리는 거기서 외판원 순회를 해야해
# 뭐냐고? 한 도시에서 출발해서 N개의 도시를 모두 거쳐서 다시 원래 도시로 돌아오는거야 
# 근데, 도시를 이동하려면 비용이 들잖아. 각 도시 간에 이동하면서 얼마의 비용이 드는지를 알려줄거야
# 그래서 구하고자 하는 것은 시작점을 포함해서 모든 노드를 방문하고 새롭게 방문하는 마지막 노드에서 다시 시작점으로 돌아왔을 때에 사용한 비용의 총합이 최소가 되는 걸 구할거야 
N = int(input())
graph = [tuple(map(int, input().split())) for _ in range(N)]

# 1<<N == 1*2^N => 1*2^4 = 16
# 현재 노드에서 모든 노드를 방문했을 때의 최소 비용을 기억할려고 dp 테이블을 만들거야
# dp[현재 노드][방문 이력] = 현재 노드에서부터 방문하지 않은 노드를 방문하고 다시 시작점으로 돌아갔을 때의 최소 비용 
dp = [[0]*(1<<N) for _ in range(N)]

# x: 현재 위치(노드)
# visit: 현재 위치를 포함해서 방문한 이력 
def dfs(x, visit):
    # 자 우리가 dp 배열에서 '인자로 주어진 visit 정보로 현재 위치(x)에 왔었는지' 찾을거야 ~!
    # 즉, 이미 인자로 받은 visit 정보와 함께 x에 온 이력이 있는지 dp테이블에서 검색하는거지
    # dp 배열에 0(초기값)이 아닌 값이 있어 => 최소비용이 dp에 담겨 있다는 것이야 
        # 있다면 0(초기값)이 아님 => 최소 비용이 이미 dp에 담겨 있을 것이야 왜냐 갔으니깐
        # 없다면 0(초기값)임=> if 조건에 맞지 않으니깐 인자로 주어진 visit 정보로 현재 위치(x)에 온적이 없네 
    if dp[x][visit]:
        return dp[x][visit]

    # 모든 노드를 방문했는지 => ex) 1111 = 15 
        # 했다면 마지막 노드(현재노드==x)에서 0(시작점)으로 돌아갈 방법이 있는지 
    # visit == (1<<N)-1 왜 이렇게 되는지에 대한 매끄러운 설명  ,,,>???
    if visit == (1<<N)-1:
        # 자자, 모든 노드를 방문했어
        # 근데, 우리가 문제에서 0에서 출발하면 0으로 다시 돌아가야하잖아
        # 현재 위치 x에서 0으로 갈 수 있는 방법이 있어???
            # 있으면 그 값을 리턴해 
        # 없으면 어차피 못 가니깐 젤 큰 값 줄게 
        if graph[x][0]:
            return graph[x][0] 
        return INF 

    # 위의 if문들의 조건에 모두 맞지 않아 여기까지 왔다는 것은 
    # 인자로 주어진 visit 정보로 x라는 노드에 처음 방문했다는걸 말하는거야 
        # 주어진 visit을 통해서 방문한 적 없는 노드가 무엇인지 알고 
        # 그곳들을 방문했을 때의 최소비용을 알아야해 

    min_cost = INF
    # 자자, 정리하자면
    # 함수 dfs의 첫 if문에서 visit정보로 현재 위치 x에 왔었는지 확인해서 안 왔으니깐 넘어왔고, 
    # 두 번째 if문에서 모든 노드를 방문 안 했으니깐 넘어왔겠지
    # 즉, 최소비용 안 구해져있고, 방문할 노드가 남아있으니깐 넘어온거야 !! 
    # 이 for문에서 i는 방문하지 않은 노드 중 현재 위치(x)에서 갈 수 있는 애들(도시)이야.

    for i in range(1, N): # 우리는 0부터 시작했으니깐 갈 수 있는 도시는 1부터 N-1까지 보면 돼

        # 현재 위치(x)에서 i로 가는 방법이 없거나
        # 이미 i 노드를 방문한 이력이 visit에 담겨 있다면 
        if not graph[x][i] or visit & (1<<i):
            continue

        # dfs로 방문하지 않은 노드들을 방문해줘야 함
        # visit | (1<<i)로 i번째 노드까지 방문했다는 것을 표시하고, 
        # graph[x][i](현재 위치 x에서 i로 갈 때 필요한 비용)을 더해
        tmp = dfs(i, visit | (1<<i)) + graph[x][i]

        # 최소 비용을 알고 싶기 때문에
        # 현재 위치 x에서 방문하지 않은 노드를 방문하는 여러가지 방법들 중 최소 비용으로 min_cost를 갱신해
        if tmp < min_cost:
            min_cost = tmp
    # 현재노드에서부터 방문하지 않은 노드를 방문하고 다시 시작점으로 돌아갔을 때의 최소 비용이야.. 
    dp[x][visit] = min_cost
    return min_cost

# x: 현재 위치(노드) => x = 0
# visit: 현재 위치를 포함해서 방문한 이력 => visit = 1
# 왜 visit에 1을 넣냐? 왜 1이냐? 현재 위치가 어디야 0이잖아. 0부터 시작할거라며 근데 visit에 현재 위치를 포함해서 방문한 이력을 넣을거라며 그럼 2진수로 0001이니깐 1이겠지.
print(f'{dfs(0, 1)}')